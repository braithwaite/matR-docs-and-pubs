% document ls() in easy lessons, rm()


\documentclass{article}
\title{Short Tutorials for Metagenomic Analysis}
\author{}
\date{}
\pagestyle{empty}
\usepackage{fullpage}

\begin{document}
\SweaveOpts{concordance=TRUE}
\maketitle

\section*{Introduction}
\noindent
These tutorials provide an introduction to metagenomic analysis using matR (Metagenomic Analysis Tools for R).  Each tutorial is short, about 10-15 minutes.  They form a progressive set, but each is pretty separate from the others, too.  This document is written at a moderate (neither low nor high) technical level.

\vspace{10pt}
\noindent
Contact us: \texttt{mg-rast@mcs.anl.gov}.

\tableofcontents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Preliminaries}
\subsection{Obtaining and Installing R}
\begin{itemize}
\item
R is free software, easily downloaded from the R Project Homepage:  \texttt{http://www.r-project.org}.  Binary versions are available for Mac and Windows systems, and source code for Linux.  Download and install the version appropriate for your system.

Users who already have R should {\em update their version}.  R and its extensions are frequently updated.  Keeping current is important to avoid nuisance errors.

\item
Add-on packages for many purposes, contributed by many people, are a great strength of R.  For example, see this list of packages, organized by application area: \texttt{http://cran.r-project.org/web/views/}.

For a repository dedicated entirely to biological functionality, see: \\
\texttt{http://www.bioconductor.org}.

\item
Now install \texttt{matR}, the MG-RAST interface add-on package.  For this, use:
<<eval=FALSE>>=
install.packages("matR", repo = 
	"http://dunkirk.mcs.anl.gov/~braithwaite/matR", 
	type = "source")
@

\item
Open an R session.  Use the following command to load the matR package:
<<eval=FALSE>>=
library(matR)
@
You would use a similar command to load any other package.

\item
matR relies on various other packages.  To install these, follow the instructions provided by running this function:
<<eval=FALSE>>=
dependencies()
@
At the time of this writing, the packages relied on by matR are: \texttt{RJSONIO}, \texttt{ecodist}, \texttt{gplots}, \texttt{scatterplot3d}.
If the \texttt{dependencies} function doesn't complete successfully, these need to be installed one at a time, as follows:
<<eval=FALSE>>=
install.packages("RJSONIO")
install.packages("ecodist")
# ...etc
@

\item
Now your R environment is ready to go!
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\subsection{Easy Lessons in R}
\begin{itemize}
\item
Here we will learn some basics of working with data in R.
<<echo=FALSE>>=
options(width=60)
@

\item
For us, two kinds of data objects are essential in R:  \texttt{matrix} and \texttt{data.frame}.  First, we create a \texttt{matrix}.  The function \texttt{sample} just creates a random permutation, as shown.
<<>>=
sample(1:200)
m <- matrix(sample (1:200), nrow=20, ncol=10)
m
@

\item
The \texttt{apply} function, below, applies the function specified by its last argument (in this case, \texttt{mean}) along the dimension of \texttt{m} specified by the second argument.  So here we calculate the row means and then the column means of \texttt{m}.
<<>>=
apply(m,1,mean)
apply(m,2,mean)
@

\item
Generally speaking, a \texttt{data.frame} is different from a \texttt{matrix} because it may contain non-numeric data.  So, now we create a \texttt{data.frame} consisting of the {\em column means} and {\em column standard deviations} of \texttt{m}, but also containing a third, descriptive column.
<<>>=
df <- data.frame(mu=apply(m,2,mean), sigma=apply(m,2,sd))
df$sample <- paste("sample", LETTERS[1:10], sep = "-")
df
@

\item
Suppose we wanted to reorder the columns.  Flexible indexing of objects is a great strength of R.  Here we {\em replace} the first and third columns of \texttt{df} with (respectively) its own third and first columns --- effectively, reordering them.
<<>>=
df [c(1,3)] <- df [c(3,1)]
df
@

\item
That almost worked, but notice that while the data moved, the column {\em labels} did not.
It is possible to refer directly to the row and column labels of a \texttt{matrix} or \texttt{data.frame}, as follows.
<<>>=
rownames(df)
colnames(df)
@
Now we finish by correcting the column labels.
<<>>=
colnames(df) [c(1,3)] <- colnames(df) [c(3,1)]
df
@

\item
Here are some commands for viewing the first elements, last elements, and overall structure of large objects.
<<>>=
head(m)
tail(m)
str(m)
str(df)
@

\item
Finally, any introduction to R should show how it easily renders statistical graphics, as with this boxplot of the columns of \texttt{m}.
<<fig=TRUE>>=
boxplot(m)
@

\item
There is a lot more to R, but the subset of commands shown here, together with the help tutorial (which is next), already enable many things!
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\subsection{Using R Help}
\begin{itemize}
\item
In R, as with any system, it's important to know how to use the help.

\item
First, locate the one-page quick reference for all matR commands:
<<eval=FALSE>>=
vignette("matR-quick-reference")
@
If that doesn't work, the quick reference is also available at: \\
\texttt{http://dunkirk.mcs.anl.gov/\~{}braithwaite/R/*******}.  \\
It may be handy to print a copy.

\item
Help on any R command is available with:
<<eval=FALSE>>=
?command
@
For example, try:
<<eval=FALSE>>=
?mean
?sample
?apply
@

\item
For keyword-based help, use the double question mark, as in these examples:
<<eval=FALSE>>=
??foo
??bar
??baz
@

\item
Finally, to retrieve an index of all help topics {\em for a specific package}, use this command, replacing \texttt{matR} with the name of the relevant package:
<<eval=FALSE>>=
library(help="matR")
@

\item
matR is updated regularly.  For a summary of the latest changes, see:
<<eval=FALSE>>=
vignette("matR-change-log")
@
The same document is also available at: \\
\texttt{http://dunkirk.mcs.anl.gov/\~{}braithwaite/R/*******}.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\subsection{Five More Lessons in R}
\begin{itemize}
\item
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\subsection{Exporting and Importing Data; Saving Images}
\begin{itemize}
\item
This tutorial explains how to get images out of R for publications, how to bring data into R from formats such as csv, tsv, or biom; and how to save data for use in future R sessions, in Excel, or with other programs.

\item
\texttt{write.table()} and \texttt{read.table()} are the workhorse commands for exporting and importing any kind of tabular data.  They have many options, as well as variants such as \texttt{read.csv()}.  The following examples show the most common options.  These functions are very flexible, though, so consult the help system to learn more.
<<eval=FALSE>>=
cc <- collection("4441679.3 4441680.3 4441682.3")
write.table(cc$raw, file="data.txt", sep="\t")
x <- read.table(file="data.txt")
x
@

\item
Additionally, matR provides a function, \texttt{asFile()}, that conveniently exports several kinds of object in a default format.  It's not flexible but may be adequate for many purposes.

\item
The functions \texttt{save()} and \texttt{load()} store R objects in a binary format for use in later R sessions.  (By convention, these files end with \texttt{.Rda}.)  This is helpful, for example, to store a metagenome collection or the result of an analysis that is computation-intensive.  Here are some examples:
<<eval=FALSE>>=
cc <- collection("4441679.3 4441680.3 4441682.3")
p <- pco(cc)
ls()
save(cc, p, file="saved_data.Rda")
rm(cc, p)
ls()
load(file="saved_data.Rda")
ls()
@

% \item 
% biom format and conversion

\item
There is an easy method to export images from an R session.  First develop the exact commands to produce the desired image interactively.  For instance, suppose we want to export the following PCoA.
<<eval=FALSE>>=
pco(Waters, main="functional level 3", 
		col=c(rep("red",12),rep("blue",12)))
@
To produce a pdf file, simply amend the code in this way.
<<eval=FALSE>>=
pdf(filename="my_pco.pdf", width=5, height=5)
pco(Waters, main="functional level 3", 
		col=c(rep("red",12),rep("blue",12)))
dev.off()
@
The function \texttt{pdf()} can be replaced with others, such as \texttt{png()}.  For more detail, consult the help system.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Examples}
\subsection{Simple Functional Comparison of Lean and Obese Mouse}
\begin{itemize}
\item This tutorial shows a basic analysis, just for demonstration, so the syntax does not need to be completely understood.  The point is to motivate the remaining tutorials.

\item First, open an R session and load matR.
<<>>=
library(matR)
@
<<echo=FALSE>>=
options(width=65)
abbrev <- matR:::abbrev
@
\item We name and identify two metagenomes of interest, create a list of correctly formatted {\em views} to specify the exact data we want, and retrieve a metagenome collection.
<<echo=FALSE>>=
load(file="mice.Rda")
@
<<eval=FALSE>>=
mice <- c(lean="4440463.3", obese="4440464.3")
v <- default.views$raw
views <- list()
length(views) <- 8
names(views) <- c("L1", "L2", "L3", "L4", "L1n", "L2n", "L3n", "L4n")
views [1:8] <- v
views[["L1"]]["level"] <- "level1"
views[["L2"]]["level"] <- "level2"
views[["L3"]]["level"] <- "level3"
views[["L4"]]["level"] <- "function"
views[["L1n"]]["entry"] <- "ns.normed.counts"
views[["L2n"]]["entry"] <- "ns.normed.counts"
views[["L3n"]]["entry"] <- "ns.normed.counts"
views[["L4n"]]["entry"] <- "ns.normed.counts"
views[["L1n"]]["level"] <- "level1"
views[["L2n"]]["level"] <- "level2"
views[["L3n"]]["level"] <- "level3"
views[["L4n"]]["level"] <- "function"
mice <- collection(mice, views)
@
\item Next, we inspect the data cursorily.
<<>>=
dim(mice$L1)
dim(mice$L4)
head(rownames(mice, "L1"))
head(rownames(mice, "L4", sep = "; "))
@
\item Heatmaps of raw and normalized counts at functional level 1 are different, but neither contrasts the samples well, as shown on the next page.
\pagebreak
<<fig=TRUE, height=4>>=
heatmap(mice, "L1", main="", cexCol=0.8, cexRow=0.5,
  labRow=abbrev(rownames(mice$L1), 15))
@
\nopagebreak
<<fig=TRUE, height=4>>=
heatmap(mice, "L1n", main="", cexCol=0.8, cexRow=0.5,
  labRow=abbrev(rownames(mice$L1n), 15))
@

\pagebreak
\item At functional level 2, the heatmap (of normalized counts) shows slightly more contrast, but still not much.\nopagebreak
<<fig=TRUE, height=5>>=
heatmap(mice, view="L2n", main="", cexCol=0.8, cexRow=0.3,
  labRow=abbrev(rownames (mice$L2n), 25))
@
%  # , lwid=c(0.2,1), lhei=c(0.2,1), margins=c(2.5,7))

\item At functional level 4, there is too much detail for a heatmap of all functions to be clear, but we can inspect the data numerically.  We compute the difference of normalized counts between the two samples, for each function.
<<>>=
differ <- abs(mice$L4n[,1] - mice$L4n[,2])
L4n.names <- rownames(mice, "L4", sep = "; ") [
  rownames(mice$L4) %in% rownames(mice$L4n)]
names(differ) <- L4n.names
hist(differ, plot=FALSE) [c("breaks","counts")]
@
\pagebreak
\item A histogram of differences is of interest.\nopagebreak
<<fig=TRUE>>=
hist(differ, plot=TRUE, main="",
  xlab="function difference", ylab="frequency", )
@

\pagebreak
\item A plot of the differences, sorted, is also informative. \nopagebreak
<<fig=TRUE>>=
sort.differ <- differ[order(differ, decreasing=TRUE)]
plot(sort.differ, pch=19, cex=0.2, 
  xlab="function rank", ylab="function difference")
@

\item Based that plot, we might heuristically choose a cutoff to look at the most significant functions.
<<>>=
sum(differ>0.4)
head(names(sort.differ))
@

\pagebreak
\item Now we can sharpen the level 4 heatmap by restricting to significant annotations.\nopagebreak
<<fig=TRUE>>=
which.rows <- rownames(mice, "L4", sep = "; ") %in% (L4n.names[differ>0.4])
heatmap(mice, view="L4", rows=which.rows, main="", 
  labRow=abbrev(rownames(mice, "L4", sep = "; ") [which.rows], 30), 
  cexCol=0.8, cexRow=0.2)
@
% # lwid=c(0.2,0.4), lhei=c(0.2,1), margins=c(3,7))

Of course, it is easy to save a record of the annotations included in this heatmap, along with their abundances.
<<>>=
m <- mice$L4
rownames(m) <- rownames(mice, "L4", sep = "; ")
asFile(m[which.rows,], file="topfunctions.tsv")
@

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\subsection{Grouping of Brazilian Coastal Water Samples}
\begin{itemize}
\item
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\subsection{A Longer Analysis Example}
\begin{itemize}
\item
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Basics}
\subsection{The Annotation Matrix}
\begin{itemize}
\item Usually, we study a matrix in which columns are labeled by samples and rows are labeled by annotation.  The annotations may be taxonomic or functional.  Also, they may be at different hierarchy levels.
\item The matrix entries may be simply the raw numbers of observations of each annotation per sample --- but they may represent other quantities, too, or be qualified in various ways.  For instance, we might be interested in the average evalue of instances of each annotation per sample.  Or, we might want to limit the annotation counts by source.
\item The process of building a metagenome collection, described in the next section, relies heavily on the matR object \texttt{view.parameters}, which makes explicit all the ways an annotation matrix may vary.  It is essentially a set of possible key-value pairs.  Choosing a compatible set of values defines a {\em view} of the collection data.
<<>>=
view.params
@
\item The parameter values \texttt{entry="ns.counts"} and \texttt{entry="normed.counts"} describe a matrix with the functions \texttt{remove.singletons()} and \texttt{normalize()}, respectively, applied to the values of a matrix with \texttt{entry="count"}.  \texttt{entry="ns.normed.counts"} means both functions applied.
\item The object \texttt{view.descriptions} contains information about the meaning of each element of \texttt{view.pararmeters}.  \texttt{view.defaults} shows what views are included in a collection by default.

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\subsection{Metagenome Collections}

\begin{itemize}
\item Metagenome collections are constructed using metagenome IDs. For example:
<<eval=FALSE>>=
IDs <- c (gut.1 = "4441695.3", gut.2 = "4441696.3")
cc <- collection (IDs)
dd <- collection ("4441679.3 4441680.3 4441682.3 4441695.3 4441696.3 4440463.3 4440464.3")
ee <- collection (file = "test-IDs.txt")
@
IDs in files should be whitespace-separated.  They can also be named...
...by project

\item Specifying metagenome IDs is only half the story.  Specific data can be requested, pertaining to the identified metagenomes.  The required syntax is slightly complicated, but enables careful analyses.
<<eval=FALSE>>=
collection (guts, 
  raw = c(entry = "count"), 
  nrm = c(entry = "normed.counts"))
collection (guts, 
  L1 = c(level = "level1"), 
  L2 = c(level = "level2"), 
  L3 = c(level = "level3"), 
  L4 = c(level = "function"))
collection (guts, 
  nog = c(source = "NOG"), 
  cog = c(source = "COG"), 
  ko = c(source = "KO"))
collection (guts, 
  lca = c(annot = "organism", hit = "lca"), 
  repr = c(annot = "organism", hit = "single"), 
  all = c(annot = "organism", hit = "all"))
@
In each example, a separate annotation matrix exists in the collection for each view on the data that was specified.  These matrices are called {\em views}.  For complete information about all the options for views, inspect the contents of these objects.
<<eval=FALSE>>=
view.parameters
view.descriptions
view.defaults
@

\item
A handy approach is to create lists of data views for easy reuse, as follows.
<<eval=FALSE>>=
top.levels <- list (
  L1 = c(level = "level1"), 
  L2 = c(level = "level2"))
all.ontologies <- list (
  nog = c(source = "NOG"), 
  cog = c(source = "COG"), 
  ko = c(source = "KO"),
  sub = c(source = "Subsystems"))
all.count.methods <- list (
  lca = c(annot = "organism", hit = "lca"), 
  repr = c(annot = "organism", hit = "single"), 
  all = c(annot = "organism", hit = "all"))
collection (guts, top.levels)
collection (guts, all.ontologies)
collection (guts, all.count.methods)
@

\item Various functions apply to collections.
<<eval=FALSE>>=
samples(cc)      # show metagenomes in the collection
projects(cc)     # show projects in the collection
names(cc)        # show names of metagenomes
views(cc)        # show the data views in the collection
viewnames(cc)    # show just the names of the views
metadata(cc)     # access metadata
@
% can assign to names

\item
Views in collections are accessed with "\$" by the name the view was given.
<<eval=FALSE>>=
cc$count
cc$normed
@
Generally, the purpose of views is to show different aspects of the same selection of metagenomes. Views can be specified when a collection is constructed as we saw, and can also be added to an existing collection:
<<eval=FALSE>>=
dd$cog <- c (source = "COG")
@

\item Names of annotations within a view are accessed with \texttt{rownames()}.
<<eval=FALSE>>=
rownames(Guts, view = "raw", sep = FALSE)
rownames(Guts, view = "raw", sep = TRUE)
rownames(Guts, view = "raw", sep = "\t")
@
The \texttt{sep} parameter ... hierarchy

\item Subsets can be taken of collections, as of other objects. For instance, here we extract the first three metgenomes of \texttt{dd} into a new collection.
<<eval=FALSE>>=
ff <- dd [1:3]
@
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\subsection{Using Metadata}

\begin{itemize}
\item Usually there is metadata associated with a metagenome collection.  Metadata fields are named in a way that reflects their hierarchical organization.  This tutorial shows how to access metadata, by several examples.

The following command lists all metadata of the \texttt{Guts} example collection.
<<echo=FALSE>>=
library(matR)
@
<<eval=FALSE>>=
metadata(Guts)
@

\item Usually there is some reason to pick out specific metadata elements.  For that purpose, metadata can be indexed.  To select elements, an arbitrary number of index vectors may be specified.  For instance, we can use one index (of length one) to get all metadata from one metagenome:
<<eval=FALSE>>=
metadata(Guts) ["4440464.3"]
@

\item Here is another example of metadata indexing:  two indices (each of length one) to get certain elements from all metagenomes.
<<>>=
metadata(Guts) ["latitude", "longitude"]
@
An alternative form returns the same output in a more convenient form.
<<>>=
metadata(Guts) ["latitude", "longitude", bygroup=TRUE]
@
In this variant NA is placed when a field is missing, as in the next example.
<<>>=
metadata(Guts) ["host_common_name", "disease", ".age", bygroup=TRUE]
@

\item Here we obtain the entire environmental package from one metagenome, using {\em one} index of {\em length} two:  only metadata fields matching both strings are selected.
<<eval=FALSE>>=
metadata(Guts) [c ("4440464.3", "env_package.data")]
@

\item Finally, this example uses three indices (all of length two) to select various elements:
<<>>=
metadata(Guts) [c ("env","temp"), c ("0464", "PI_organization"), 
  c ("0464","biome")]
@

\item Metadata can be handled independently of annotation data.  This can save time in situations where annotation data is not needed.  A metadata object can be built in exactly the same way as a collection, as shown.
<<eval=FALSE>>=
mm <- metadata("4441679.3 4441680.3 4441682.3 4441695.3 4441696.3")
@
Now \texttt{mm} can be used just as \texttt{metadata(Guts)} was used, above.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Analysis}
\subsection{Analysis Functions in Detail}
\begin{itemize}
\item
At present matR provides these customized analysis functions:  \texttt{boxplot()}, \texttt{pco()}, \texttt{heatmap()}, \texttt{parcoord()}, and \texttt{sigtest()}.

\item
Each reimplements basic functions with added features and helpful default settings.  In most cases, options to the basic functions also apply to the matR versions.  More experienced users can use the basic functions directly as needed.  They are: \texttt{base::boxplot()}, \texttt{ecodist::pco()}, \texttt{graphics::points()}, \texttt{graphics::text()}, \texttt{gplots2::heatmap.2()}, \texttt{stat::parcoord()}, plus several individual statistical test functions from the \texttt{stat} package.

options to the matR function
options to base function

\item {Boxplot Annotations}
Boxplots can be useful to gain a general idea of the distribution of annotation counts in each sample of a collection.
% <<fig=TRUE>>=
% boxplot (Waters, notch = TRUE, pch = 19, cex = 0.5, names = names (waters),
% 				 main = "Annotation Diversity at Function Level 3", cex.axis = 1.1)
% @

% \item {Principal Coordinates Analysis}
% # <<fig=TRUE, height=4.5>>=
% # col <- factor (metadata (cc) ["biome"])
% # levels (col) <- c ("#1F78B4", "#E31A1C", "#B15928")
% # col.vec <- as.character (col)
% # pco (cc, comp = c (1,2), main = "First and Second Principal Coordinates", 
% #   col = col.vec, labels = "", cex = 1.5)
% # @
% <<fig=TRUE>>=
% pco (cc, comp = c (2,3,4), sub = "Principal Coordinates 2 to 4", cex.sub = 1.5,
%   main = "", color = col.vec, labels = "", cex = 1.5, lty.hplot="dashed", 
%   mar = c (5,5,0,3))
% @

\item {Heatmap Dendrograms}
% # <<echo=false>>=
% red.yellow <- rgb (colorRamp(c ("#FFFFCC", "#800026")) (seq(0, 1, length = 20)), max = 255)
% @
% <<fig=TRUE, height=4>>=
% cc <- collection (c ("4441679.3", "4441680.3", "4441682.3", "4441695.3", 
%   "4441696.3", "4440463.3", "4440464.3"),
%   first = c (level= "level1", entry = "normed"),
%   second = c (level= "level2", entry = "normed"))
% heatmap (cc, view = "first", main = "")
% @
% <<fig=TRUE, height=4>>=
% heatmap (cc, view = "second", main = "", col = red.yellow)
% @
% <<fig=TRUE, height=4>>=
% heatmap (cc, view = "second", col = red.yellow, main = "", 
%   rows = sigtest(cc$second, groups = metadata(cc)["host_common_name"]) $
%     p.value < 0.1)
% # @
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\subsection{Other Useful R Packages}
\begin{itemize}
\item
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\section{Miscellaneous}
\subsection{Calling the MG-RAST API Directly}
\begin{itemize}
\item The full functionality of the MG-RAST API is available through matR.  For details on the API, visit its homepage, \texttt{http://api.metagenomics.anl.gov}.

\item Many API resources are available through the mid-level interface function, \texttt{mGet()}.  The following examples establish the general pattern.
<<eval=FALSE>>=
mGet("sequenceSet/blah...")
@

\item When you need more control, use the low-level function \texttt{callRaw()}, which only prepends the API server name and appends the session authorization key (if set) to its argument.
<<eval=FALSE>>=
callRaw("matrix/....blah")
@

\item Most API resources are returned as JSON objects and automatically parsed by \texttt{mGet} (or \texttt{callRaw}).  JSON parsing can be forestalled.  

\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak
\subsection{Using R within an iPython Notebook}
\begin{itemize}
\item
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\end{document}